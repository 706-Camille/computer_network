# Application layer

## CS paradigm

##### server는 permanent IP address를 갖고 항상 돌아가고 있다. 반면에 client는 필요할때 접속
##### client는 서로 직접적으로 통신하지 않는다.
ex) HTTP, IMAP, FTP
##### File distribution time(CS)
##### Dc-s >= max{NF/Us, F/Dmin} N이 증가함에 따라 linear하게 증가, client 가 증가함에 따라 보내줘야하는 file copy가 같이 증가하기때문

## p2p (peer to peer)

##### server가 없다.
##### 가장 큰 특징은 self scalability이다. ex) p2p 파일 공유 어플리케이션에서는 각 피어들이 파일을 요구함으로 써 작업 부하를 만들어내지만 각 피어들은 또한 파일을 다른 피어들에게 분배함으로써 그 시스템에 서비스 능력을 추가한다. CS구조에 비교하면 cost 측면에서 효율적이다. (CS구조에서는 server가 모든 작업을 처리하기 때문)
##### File distribution time(P2P)
##### client가 증가함에 따라 처리해야할 file이 증가하지만 동시에 file 분배하는 peer도 증가하여 (ability 증가) upload rate도 같이 증가한다. 따라서 CS구조와 달리 linear하게 증가하지 않는다.

## P2P file distribution : BitTorrent
##### file을 256KB chunk 단위로 divide, 토렌트내 peer들끼리 chunk를 주고 받는다.
##### 현시점에서 chunk 단위로 내가 원하는 파일을 가장 잘 줄수 있는 peer를 tracker를 이용해서 찾아야함. 가장 효과적으로 내가 필요한 파일들을 받아서 assemble

## IPC (inter-process-communication)

##### 두개의 HOST 간에 통신을 IPC로 했다? -> X same Host에서 process간 통신, 두개의 host간에 통신은 socket 통신
##### process : 호스트 내 돌아가고 있는 프로그램

## Socket

### Addressing Processes
##### IP address로 HOST를 식별 port numbers로 HOST내에 있는 관련된 process(application)를 찾는다.
##### example port numbers : 
  HTTP server : 80
  mail server : 25
이것은 표준이다, 따르지 않으면 범용성 X 

## transport service does
##### data integrity : 데이터 무결성, 어떤 앱들은 신뢰성이 확보된 데이터 전송이 요구됨
##### timing : 정해진 시간내에 가야함
##### throughput : 처리량
##### security : 보안

## TCP service
##### reliable transport : 송수신 과정에서 데이터 신뢰성
##### flow control : receiver쪽 buffer 가 원할한지 체크하며 적절하게 control
##### congestion control : 네트워크 상 overload 를 낮춰줘야함 route를 바꿔주는게 아닌 보내는 량을 줄임. receive단을 보는게 아닌 전체 네트워크 망을 보고 조절하는게 congestion control

## UDP service

## HTTP
##### TCP 기반(신뢰성 있는 통신) loss x
##### client가 TCP connection을 초기에 init, port는 80
##### server accepts TCP connection from client
##### HTTP 는 stateless, 즉 상태를 보관하지 않으므로 클라이언트의 요청에 어느 서버가 응답해도 상관이 없다.
##### stateless의 단점을 보완 -> browser coockie나 서버 세션등을 사용해 상태를 유지
##### cookies 는 client 에 저장 session은 server에 저장 (connection이 유지 되어야함)

## Non-persistent HTTP (1.0)
##### TCP connection 을 열고 object 하나를 보내고 닫음
##### multiple objects를 받으려면 여러번의 connections 이 요구됨
##### response time은 어떻게 될까?
##### RTT = 왕복시간, cilent 가 server에 요청을 시작한 후 response를 받는 데 걸리는 시간
1. 먼저 clinet 에서 connect 시도 -> Server accept  >> one RTT time
2. clinet 에서 object request -> Server transmit file and response to return >> one RTT time + transmission time
##### Non-persistent HTTP reponsetime = 2 * RTT  + file transmission time

## Persistent HTTP (1.1)
##### server와 client간 한번의 TCP connection에 여러개의 objects가 전송될 수 있다.

## HTTP (2.0)
##### HTTP 1.1의 HOL 문제 -> objects 들을 frame 단위로 나눠서 Round Robin 방식으로 해결

## head-of-line (HOL) (문제로 나올 수 있음 ex : HTTP 1.1의 문제를 서술하시오)
##### HTTP 1.1의 문제(HOL) : FCFS(first-come-first-served scheduling) 방식으로 서버가 response를 주는데, 이때 처리량이 작은 object들이 큐 앞에 대기하고 있는 처리량이 큰 object가 transmission 될 때까지 기다려야함.

## Web caches
##### browser가 HTTP requests를 모두 cache로 보냄
1. if object가 캐쉬내에 있다면 object를 client 에게 return 
2. else object 를 origin server에 요청 cache가 object를 recieved, return object to client

## Mail access protocols
###### SMTP (Simple Mail Transfer Protocol)(to send)
###### IMAP (동기화 O) or POP (동기화 X) to retrieve e-mail message

## DNS : Domain Name Sysmtem
1. hostname to IP address translation
2. a Distributed, hierarchical Database
###### DNS 서버는 계층적으로 구성돼있음. 왜? -> 수많은 request가 중앙 집중화된 서버에 몰리면? 너무 많은 부하때문에 overhead 발생. 따라서 서버를 Root, Top Level Domain, Authoritative 계층화 

## Local DNS Name Server
###### cache 와 비슷한 역할을 한다.

## iterated query

## recursive query 



