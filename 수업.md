[# Application layer

## CS paradigm

##### server는 permanent IP address를 갖고 항상 돌아가고 있다. 반면에 client는 필요할때 접속
##### client는 서로 직접적으로 통신하지 않는다.
ex) HTTP, IMAP, FTP
##### File distribution time(CS)
##### Dc-s >= max{NF/Us, F/Dmin} N이 증가함에 따라 linear하게 증가, client 가 증가함에 따라 보내줘야하는 file copy가 같이 증가하기때문

## p2p (peer to peer)

##### always on server가 없다.
##### 가장 큰 특징은 self scalability이다. ex) p2p 파일 공유 어플리케이션에서는 각 피어들이 파일을 요구함으로 써 작업 부하를 만들어내지만 각 피어들은 또한 파일을 다른 피어들에게 분배함으로써 그 시스템에 서비스 능력을 추가한다. CS구조에 비교하면 cost 측면에서 효율적이다. (CS구조에서는 server가 모든 작업을 처리하기 때문)
##### File distribution time(P2P)
##### client가 증가함에 따라 처리해야할 file이 증가하지만 동시에 file 분배하는 peer도 증가하여 (ability 증가) upload rate도 같이 증가한다. 따라서 CS구조와 달리 linear하게 증가하지 않는다.

## P2P file distribution : BitTorrent
##### file을 256KB chunk 단위로 divide, 토렌트내 peer들끼리 chunk를 주고 받는다.
##### 현시점에서 chunk 단위로 내가 원하는 파일을 가장 잘 줄수 있는 peer를 tracker를 이용해서 찾아야함. 가장 효과적으로 내가 필요한 파일들을 받아서 assemble

## IPC (inter-process-communication)

##### 두개의 HOST 간에 통신을 IPC로 했다? -> X same Host에서 process간 통신, 두개의 host간에 통신은 socket 통신
##### process : 호스트 내 돌아가고 있는 프로그램

## Socket

### Addressing Processes
##### IP address로 HOST를 식별인

## HTTP
##### TCP 기반(신뢰성 있는 통신) loss x
##### client가 TCP connection을 초기에 init, port는 80
##### server accepts TCP connection from client
##### HTTP 는 stateless, 즉 상태를 보관하지 않으므로 클라이언트의 요청에 어느 서버가 응답해도 상관이 없다.
##### stateless의 단점을 보완 -> browser coockie나 서버 세션등을 사용해 상태를 유지
##### cookies 는 client 에 저장 session은 server에 저장 (connection이 유지 되어야함)

## Non-persistent HTTP (1.0)
##### TCP connection 을 열고 object 하나를 보내고 닫음
##### multiple objects를 받으려면 여러번의 connections 이 요구됨
##### response time은 어떻게 될까?
##### RTT = 왕복시간, cilent 가 server에 요청을 시작한 후 response를 받는 데 걸리는 시간
1. 먼저 clinet 에서 connect 시도 -> Server accept  >> one RTT time
2. clinet 에서 object request -> Server transmit file and response to return >> one RTT time + transmission time
##### Non-persistent HTTP reponsetime = 2 * RTT  + file transmission time

## Persistent HTTP (1.1)
##### server와 client간 한번의 TCP connection에 여러개의 objects가 전송될 수 있다.

## HTTP (2.0)
##### HTTP 1.1의 HOL 문제 -> objects 들을 frame 단위로 나눠서 Round Robin 방식으로 해결

## head-of-line (HOL) (문제로 나올 수 있음 ex : HTTP 1.1의 문제를 서술하시오)
##### HTTP 1.1의 문제(HOL) : FCFS(first-come-first-served scheduling) 방식으로 서버가 response를 주는데, 이때 처리량이 작은 object들이 큐 앞에 대기하고 있는 처리량이 큰 object가 transmission 될 때까지 기다려야함.

## Web caches
##### browser가 HTTP requests를 모두 cache로 보냄
1. if object가 캐쉬내에 있다면 object를 client 에게 return 
2. else object 를 origin server에 요청 cache가 object를 recieved, return object to client

## Mail access protocols
###### SMTP (Simple Mail Transfer Protocol)(to send)
###### IMAP (동기화 O) or POP (동기화 X) to retrieve e-mail message

## DNS : Domain Name Sysmtem
1. hostname to IP address translation
2. a Distributed, hierarchical Database
###### DNS 서버는 계층적으로 구성돼있음. 왜? -> 수많은 request가 중앙 집중화된 서버에 몰리면? 너무 많은 부하때문에 overhead 발생. 따라서 서버를 Root, Top Level Domain, Authoritative 계층화 

## Local DNS Name Server
###### cache 와 비슷한 역할을 한다.

## iterated query

## recursive query 

# Transport layer
##### transport portocols run in end systems 
1. send side : application의 msg를 segment 단위로 나누어 network layer에 넘겨준다
2. receiver side : segment를 msg로 reassemble해 application layer에 넘겨준다.

## multiplexing
##### 소켓으로부터의 데이터를 모으고, 각 데이터를 헤더 정보와 함께 캡슐화하여, segment를 network layer에 전달하는 것을 multiplexing이라 한다.

## demultiplexing
##### transport layer에 전달된 segment header를 확인하여 그에 맞는 socket에 전   ㄷ달하는 작업.

## connectionless demultiplexing
##### UDP protocol, 보내는 source port가 틀려도 dest port가 같다면 동일한 소켓을 사용한다.
##### 즉, dest IP address와 dest port num이 같으면 동일한 소켓. source IP, source port 상관 x

## connection-oriented demultiplexing
##### TCP portocol, source IP address, source port, dest IP address, dest port, 4개의 튜플로 TCP socket을 구분한다.
##### server는 client마다 다른 socket을 생성하고 connection을 setup 하고 그 connection을 통해 통신한다.
##### 따라서 connection을 통해 receiver에 buffer 상태를 확인 가능하고 connection 경로의 혼잡도 파악가능하므로 TCP protocol의 주요 특징인 flow control, congetion control이 가능하다.
##### source IP address, source port, dest IP address, dest port 어느 하나가 다르면 소켓이 다름.

## TCP
- reliable한 전송
- in-order-delivery : 데이터 순서가 차례대로 잘 전달되도록 관리
- congestion control : 네트워크 혼잡에 따라 전송속도를 제어.
- flow control : receiver의 buffer 상태에 따라 전송속도를 제어
- connection setup : reliable한 전송을 위해, 3-way-handshake를 통한 connection setup 후 데이터를 주고 받는다.
## UDP
- unreliable 전송 : 데이터가 손실이 나도 계속해서 전송.
- no connection : TCP에서 3-way-handshake같은 connection setup 과정이 없기 때문에 속도 면에서는 우월하다.
- congestion & flow control x X : TCP 기반에서 connection이 setup 되면 receiver의 buffer 상태를 TCP protocol header를 통해 전달 받고 flow control이 가능하다. 또 session을 점유하는 TCP와 달리 network congestion을 알 수 없으므로 congestion control도 할 수 없음.

## Stop-and-wait (ARQ protocol)
##### sender는 receiver가 현재 pck을 정확하게 수신했음을 알리기 전까지 새로운 데이터를 전달하지 않는다. pkt을 보내고 해당하는 ack가 오기전에 다른 pkt을 전송하지 않음. ack가 정해진 timer(RTT 기준으로 정해짐)시간 내에 오지 않으면 (expired) 해당 pkt을 다시 재전송해준다(신뢰성). premature timeout 일 경우 아직 ack가 도착하기전에 재송신 하는 경우가 많아진다. -> 비효율적, timeout 시간이 너무 길어도 pkt loss에 대한 response가 너무 느려지므로 비효율적. 따라서 적당한 timeout 설정이 필요하다.

## GO-Back-N (pipelined protocol)
##### stop-and-wait 방식에서 현재 pkt 에 대한 ack가 올때까지 다른 pkt을 전송하지 않는 것은 비효율적이다. 따라서 GO-BACK-N 방식에서는 window size N 만큼 pkt들을 ack가 올때까지 기다리지 않고 전송한다. comulative ack를 수신할때마다 window를 한칸씩 slide한다. 만약 base의 ack가 timer 시간 내에 수신되지 않으면(expired), 다시 해당 seqNum으로 돌아가서 window size 만큼 pkt들을 재송신한다. 이때 이미 sent된 pkt(receiver측에서 discard됨)들도 재송신된다 (비효율). 

## Selective Repeat (pipelined protocol)
##### receiver는 받은 pkt들에 대한 각각 individual ack를 sender에게 전달한다. sender는 ack가 오지 않은 pkt들만 개별적으로 재전송하게됨. GO-Back-N의 비효율 해결.

## TCP Fast Retransmit
##### sender가 똑같은 ack를 3번 받았다면, 그 pkt이 잘 전달되지 못했다고 생각하고 빠르게 재전송하는 것을 의미. timeout이 되기전에 해당 pkt을 빠르게 재전송 해줄 수 있음.

## TCP Flow Control
##### sender와 receiver의 1대1 connection을 통해 TCP header의 receive window field를 보고 receiver의 buffer 상태를 알 수 있음, 그에 따라 sender가 data를 보내는 속도를 제어.

## TCP 3-way handshake, 4-way handshake
##### connection을 setup하는 과정, cleint가 synpkt 을 보내고 sever synbit = 1 인 ack를 보내준다. client가 다시 ack를 보내주면 connection이 완료된다.
##### 4-way hand shake는 Fin

## congestion control (혼잡 회피, 혼잡 제어)
##### 참여한 모든 connection의 전체 혼잡도를 보고 보내는 데이터를 제어. receiver
