# 7일차 Network Layer
## NAT : Network address translation 
##### 외부 public 망에서는 class 기반 IP 주소를 따른다. Local private 망에서는 라우터가 맵핑된 table을 보고 내부 IP(임의로 지정된)로 변환. IPv6로 가는 것을 늦춰줌
## IPv6
##### source address, destination address 각각 16byte. 40 byte중 32byte를 차지. 따라서 header field를 IPv4 에 비해 많이 줄였음 (지연 시간을 줄이기 위한 목적). fragmentation field x Check sum x (상위 layer에서 해줌), hop limit(TTL)
## Transition from IPv4 to IPv6
##### tunneling : 모든 라우터를 동시에 업그레이드 할 수는 없다. 따라서 IPv4 와 IPv6를 혼용해서 사용해야 하는데, 이때 사용하는 기법이 tunneling 기법이다. 하위 layer에서 상위 layer로 올라갈때 header를 떼는 것과 유사. IPv6 header에 IPv4 header를 덧붙인다.
## SDN
##### centralized routing controller를 통해 라우팅을 제어.
## Routing protocols
##### goal : end to end 네트워크 라우터들의 "good" path를 결정하는 것
##### global: "link state" algorithms (Dijkstra's algorithm)
##### decentralized: "distance vector" (Bellman-Ford equation)(dynamic programming)

## link state
##### global : Link state 알고리즘은 네트워크 전체의 상태정보를 각 router가 알고 있다. 즉, 네트워크 전체 경로를 보고 "good" paths를 결정한다.
## distance vector
##### decentralized : 각 router들은 neighbor node로 가는 cost를 알고 있다. 
##### dx(y) = min {c(x,v) + dv(y)}
##### x의 다음 node 들에 대한 distance vector는 x가 계산, 다음 node들에 대한 cost는 neighbor node가 notify 해준다.
##### 인접 노드 중 c(x,v) + dy(y) 가장 최소 비용인 v를 선택. 
##### 각각의 node들은 자기를 기준으로 해서 direct link를 갖고 있는 node에 대한 distance vector는 직접 구한다.
##### 이를 각 node끼리 교환하여 추정치를 recompute. distance vector 값이 update 됐다면, 다시 notify neighbors. (iterated)

 
## link state와 distance vector의 특징과 차이

##### 그래서 링크 스테이트 알고리즘은 각각의 노드들이 다른 모든 노드들과 이제 이야기를 하는 구조입니다. 
##### 바로 플로딩이라는 절차를 통해서 내가 갖고 있는 정보들을 다른 모든 노드에게 전파시키는 과정을 거치게 됩니다. 그래서 각각의 이제 링크의 코스트들을 이제 말해주는 거죠. 그 다음에 그렇게 해서 전체 토폴로지를 만든 다음에 우리가 배웠던 다익스트라 알고리즘을 각각의 노드들이 직접 돌리게 되죠.  그래서 각각의 노드들은 다익스트라 알고리즘을 통해서 모든 데스티네이션에 대해서 최적의 아웃풋 링크를 도출하게 됩니다. 그래서 나중에는 ip 주소만 보고서 얘는 몇 번 링크로 보내는 게 제일 좋다라는 거 바로 알 수 있죠. 

##### 디스턴스 벡터 알고리즘도 똑같이 이제 모든 데스트네이션에 대해서 이제 아웃풋 링크를 결정하는 건데 이제 방법이 좀 다르죠 각각의 노드들이 자신과 직접 연결된 이웃과만 소통을 합니다. 그래서 플로팅 모든 노드에 전파시키는 게 아니라 자기 노드한 자기 이웃 노드한테만 전파를 시킵니다. 그리고 이웃 노드는 자기 이웃 노드한테 받은 정보를 가지고서 디스턴스 벡터 매번 업데이트를 합니다. 그리고 그 업데이트한 결과를 가지고 라우팅을 매 순간 수행을 합니다. 업데이트할 때 이제 사용하는 이큐에이션은 우리가 벨만 포드 이큐에이션이다라고 이야기를 했었습니다.

# 9일차 Network Layer
## AS : "Autonomous System" (자율 시스템)
##### 네트워크는 너무 방대하다. 전체 망을 고려해서 routing 하는 것은 너무 복잡하고 어려운 일이다. 따라서 라우터들을 regions 별로 나누어 관리.
##### 각각의 area별로 여려개의 router들을 묶어서 하나의 region을 형성(AS)

## intra-AS routing (intra와 inter를 잘 구분해야함)
#####  area 안쪽에서 동작, 같은 AS내에 속한 hosts, routers 라우팅. link state, distance vector 모두 활용 가능.
##### RIP : Routing Information Protocol
##### OSPF : Open Shortest Path First (IS-IS protocol OSPF와 똑같음)
###### Hierarchical OSPF area 내의 internal routers. area border routers(경계), backbone router(외부와 connect), boundary router 라우터들을 hierarchical하게 관리함.
##### IGRP : interior Gateway Routing Protocol (게이트 웨이 안쪽)

## inter-AS routing : AS 간의 routing
##### inter-AS 역할 : external destination 접근가능한 라우터들을 수집하고, AS내에 있는 라우터들에게 정보를 전파하는 역할을 함. (큰 단위를 결정한다)
##### inter-AS routing : BGP (intra BGP X 틀린답 !)
### BGP (Border Gateway Porotocol)
##### eBGP : 접하고있는 AS들로 부터 reachability information을 수집
##### iBGP : 수집한 reachability information을 AS내의 라우터에 전파.
##### Policy-based routing : policy에 routing이 달라질 수 있다.

## Hot Potato Routing
##### AS내에서 가장 cost가 낮은 local gateway에게 넘긴다. 이때 inter-domain cost는 고려하지 않는다.
## ICMP : internet control message protocol
##### network-layer에서 사용
## SNMP protocol
##### SNMP는 간단한 네트워크 관리 프로토콜로, 네트워크 장치와 그 기능을 관리하고 모니터링하는 데 사용되는 표준 프로토콜입니다. 이는 네트워크 장치 간의 MIB를 교환하는 응용 계층 프로토콜로, 다양한 네트워크 장치 및 시스템을 효과적으로 관리하는 데 도움이 된다.

# 10일차 Link layer

## Link layer services
##### flow control
##### error detection
##### error correction

## NIC : Network Interface Card
##### link layer가 구현되는 hardware
## MAC addresses : Link layer
##### 한 hop을 건너는 것만 관심이 있다.

## EDC : Error Detection and Correction bits
##### 오류를 식별하고 수정하는 역할. datagram 뒤에 EDC field가 있음. field가 클수록 detection and correction 성능이 좋아진다.

### Error Detection
##### parity checking
single bit parity : detect 만 가능
two - dimensional bit parity : detect and correct single bit errors
##### Internet checksum
##### CRC : Cyclic redundancy check

## multiple access protocols
##### 하나의 매체를 동시에 쓰다보니 collision이 발생. 이 collision을 어떻게 낮출것인지가 핵심.
### channel partitioning : frequency or time or code로 채널을 partitioning. -> collision이 발생하지 않는다.
##### FDMA (frequency division multiple access) : frequency를 나누어서 채널을 할당. collision이 발생하지 않음.
##### TDMA (time division multiple access) : time slots를 나누어서 사용자에게 할당. collision이 발생하지 않음.

### Tatking turns : 순서를 주는 것, collision이 발생하지 않음
##### polling, token passing (token을 넘기며 각 노드들에게 통신권한을 줘서 충돌을 방지)

### random access : collision 발생.
##### Pure (unslotted) ALOHA : 비동기화, frame size가 동일하지 않아 collision이 자주 발생함.
##### Slotted ALOHA : frame size가 동일, 노드들이 동기화, 

